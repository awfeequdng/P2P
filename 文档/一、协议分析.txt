
/*--------------------------------------------------------------------
　　　/\~~~~~~~~~~~~~\　　　▓　　^*^　　　☆　　$$　 .☆ 
　　./　\~~~▓~　 ~~~~\ ◆　　圣诞 .快乐　 *　 $◢◣$　 * 
　　/ ^^ \ ══════\.◆　　　 *　*　　*　 $◢★◣$　 * 
　..▎[]　▎田　田 ▎ |┃◆　 .　　　　　*　 $◢■■◣$　 * 
　&&▎　　▎　　　 ▎'|'▎ @　　　　　　　* $◢■■■◣$ * 
＃ ■■■■■■■■■■〓▄▃▂▁愿你圣诞快乐︸︸||︸︸ 


				说明文档
版本：1.0
时间：2015.08.02
作者：Faker

--------------------------------------------------------------------*/


传输协议：
	代码使用服务器中转、UDP 打洞这两种方式进行对 nat 的穿透，以实现P2P传输功能
	传输协议使用 udp。

数据加密：
	为了保证P2P传输的安全性，所有数据在发送之前都经过数据加密，加密算法为 AES256.
	同时，在每个数据包的包头都增加了 密码 验证以及 crc 校验码。
	
udp打洞原理：
	由于nat的特性，使得不同内网之下的主机之间无法之间通信。目前市场上有许多nat穿越技术，
	其中最为简单的是 udp 打洞。
	udp打洞原理是利用一个协助服务器，使得通信双方能知道对方的IP端口号，彼此之后往对方发送一个
	打洞包，以此实现nat穿越。更多详情参考：
	http://www.cnblogs.com/cinlap/articles/2684330.html
	

数据格式：
	所有数据包都必须经过封装，例如我们要发送的数据为 data，则需要在data前面增加一个数据包头，已经
	协议头。
	封装的格式如下：
	head + proto + data
	
	其中 head 为头部， 40 个字节
	proto 为二级传输协议头
	data 为数据内容
	
	head格式如下：
	struct check_head{
		unsigned int affairs;		/* 处理事务，用以实现 P2P 传输机制 */
		char name[USER_NAME_LEN];	/* 本机名称ID 24 个字节 */
		unsigned int passwd;		/* 网络传输的密码，该密码必须正确，否则该数据不被处理，不过暂时没有做这个功能 */
		unsigned int key;		/* 数据包唯一编号，相同编号的数据包将会被过滤掉，丢弃不处理 */
		int crc;			/* 数据校验，对前面的字段进行异或校验，接收到数据后，会读取crc，并对其做校验，校验失败则不做丢弃该数据包 */
	};

	proto 格式如下：52 个字节
	struct proto_c_send_data{
		char src_name[USER_NAME_LEN];		/* 源 名称，也就是该数据包是谁发送的 */
		char dest_name[USER_NAME_LEN];		/* 目标名称，该数据包是要发送给谁 */=
		int c_proto;						/* 传输协议 */
		int key;							/* 键值 */
	};


传输过程：

	服务器转发流程
	1	例如主机 A 处于 natA 之下
		主机 B 处于 natB之下
		主机 A 想要发送msg给 主机B
	
	步骤		主机A
	1			主机A 封装好数据包 其中 head->affairs=0x4
				proto->src_name = 自己名字
				proto->dest_name = 主机B 的名字
				data 为要发送的数据 msg
				然后将数据发送给服务器
				
	2			服务器
				服务器收到数据后，根据 dest_name 在数据库中找到该主机的信息
				如果该主机不在线，则回复主机 A ：对方不在线
				如果在线 则将该数据包完整的发送给主机B
				
	3			主机B
				收到服务器转发过来的数据。将 src_name 该成自己的名字
				dest_name 改成对方的名字。
				head->affairs=0x5		//表示应答
				再次提交服务器
				
	4			服务器
				服务器收到数据后，根据 dest_name 在数据库中找到该主机的信息
				如果该主机不在线，则不做任何处理
				如果在线 则将该数据包完整的发送给主机B
	
	5			主机A
				收到服务器转发过来的应答包，则表明数据传输完成。
				
	至此，服务器转发的流程结束
	
	
	UDP打洞传输
		任何时候，主机A第一次发送数据给主机B的时候，都是走服务器中转，然后接下将进入 P2P 尝试传输环节
		
	1			主机A
				主机A将从服务器上获取主机B的信息，此时发送的数据格式为 
				head + get_info 
				其中 get_info 的格式如下：
				struct proto_c_get_lient{
					char name[USER_NAME_LEN];		//要获取的节点名字
				};
				主机A构造好数据
				head->affairs=0x3
				get_info->name = 希望得到该客户端的信息的名字
				
	2			服务器
				收到数据后，根据 name 在数据库中找到该主机的信息
				如果该主机不在线，则回复主机 A ：对方不在线，然后退出
				如果在线 则把主机B的信息发送给主机A，主要由 主机B 的IP 端口号
				同时，服务器吧主机A的信息发送给主机B，告诉主机B：请往主机A发送一个打洞包
				
	3			主机B
				收到服务器的请求后，往指定的IP端口发送一个大洞包
				
	4			主机A
				得到主机B的信息后，往主机B发送一个 test 测试包
				
	5			主机B
				如果主机B 能收到主机A发送过来的test包，则表明有建立 udp 打洞传输的可能性。
				收到 test测试包，将返回一个 test_ack 应答包
				
	6			主机A
				如果收到对方的的 test ack 应答包，则表示udp打洞传输是可行，之后的数据传输将通过
				udp 打洞的方式发送给对方，不需要经过服务器，减少服务器的负担
				